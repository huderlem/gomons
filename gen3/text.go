package gen3

import (
	"fmt"
	"strings"
)

const endOfString = 0xFF

var charmap = map[rune]byte{
	' ':  0x00,
	'0':  0xA1,
	'1':  0xA2,
	'2':  0xA3,
	'3':  0xA4,
	'4':  0xA5,
	'5':  0xA6,
	'6':  0xA7,
	'7':  0xA8,
	'8':  0xA9,
	'9':  0xAA,
	'!':  0xAB,
	'?':  0xAC,
	'.':  0xAD,
	'-':  0xAE,
	'·':  0xAF,
	'…':  0xB0,
	'“':  0xB1,
	'”':  0xB2,
	'‘':  0xB3,
	'\'': 0xB4,
	'♂':  0xB5,
	'♀':  0xB6,
	'¥':  0xB7,
	',':  0xB8,
	'×':  0xB9,
	'/':  0xBA,
	'A':  0xBB,
	'B':  0xBC,
	'C':  0xBD,
	'D':  0xBE,
	'E':  0xBF,
	'F':  0xC0,
	'G':  0xC1,
	'H':  0xC2,
	'I':  0xC3,
	'J':  0xC4,
	'K':  0xC5,
	'L':  0xC6,
	'M':  0xC7,
	'N':  0xC8,
	'O':  0xC9,
	'P':  0xCA,
	'Q':  0xCB,
	'R':  0xCC,
	'S':  0xCD,
	'T':  0xCE,
	'U':  0xCF,
	'V':  0xD0,
	'W':  0xD1,
	'X':  0xD2,
	'Y':  0xD3,
	'Z':  0xD4,
	'a':  0xD5,
	'b':  0xD6,
	'c':  0xD7,
	'd':  0xD8,
	'e':  0xD9,
	'f':  0xDA,
	'g':  0xDB,
	'h':  0xDC,
	'i':  0xDD,
	'j':  0xDE,
	'k':  0xDF,
	'l':  0xE0,
	'm':  0xE1,
	'n':  0xE2,
	'o':  0xE3,
	'p':  0xE4,
	'q':  0xE5,
	'r':  0xE6,
	's':  0xE7,
	't':  0xE8,
	'u':  0xE9,
	'v':  0xEA,
	'w':  0xEB,
	'x':  0xEC,
	'y':  0xED,
	'z':  0xEE,
	'▶':  0xEF,
	':':  0xF0,
	'Ä':  0xF1,
	'Ö':  0xF2,
	'Ü':  0xF3,
	'ä':  0xF4,
	'ö':  0xF5,
	'ü':  0xF6,
}

var reverseCharmap = map[byte]rune{
	0x00: ' ',
	0xA1: '0',
	0xA2: '1',
	0xA3: '2',
	0xA4: '3',
	0xA5: '4',
	0xA6: '5',
	0xA7: '6',
	0xA8: '7',
	0xA9: '8',
	0xAA: '9',
	0xAB: '!',
	0xAC: '?',
	0xAD: '.',
	0xAE: '-',
	0xAF: '·',
	0xB0: '…',
	0xB1: '“',
	0xB2: '”',
	0xB3: '‘',
	0xB4: '\'',
	0xB5: '♂',
	0xB6: '♀',
	0xB7: '¥',
	0xB8: ',',
	0xB9: '×',
	0xBA: '/',
	0xBB: 'A',
	0xBC: 'B',
	0xBD: 'C',
	0xBE: 'D',
	0xBF: 'E',
	0xC0: 'F',
	0xC1: 'G',
	0xC2: 'H',
	0xC3: 'I',
	0xC4: 'J',
	0xC5: 'K',
	0xC6: 'L',
	0xC7: 'M',
	0xC8: 'N',
	0xC9: 'O',
	0xCA: 'P',
	0xCB: 'Q',
	0xCC: 'R',
	0xCD: 'S',
	0xCE: 'T',
	0xCF: 'U',
	0xD0: 'V',
	0xD1: 'W',
	0xD2: 'X',
	0xD3: 'Y',
	0xD4: 'Z',
	0xD5: 'a',
	0xD6: 'b',
	0xD7: 'c',
	0xD8: 'd',
	0xD9: 'e',
	0xDA: 'f',
	0xDB: 'g',
	0xDC: 'h',
	0xDD: 'i',
	0xDE: 'j',
	0xDF: 'k',
	0xE0: 'l',
	0xE1: 'm',
	0xE2: 'n',
	0xE3: 'o',
	0xE4: 'p',
	0xE5: 'q',
	0xE6: 'r',
	0xE7: 's',
	0xE8: 't',
	0xE9: 'u',
	0xEA: 'v',
	0xEB: 'w',
	0xEC: 'x',
	0xED: 'y',
	0xEE: 'z',
	0xEF: '▶',
	0xF0: ':',
	0xF1: 'Ä',
	0xF2: 'Ö',
	0xF3: 'Ü',
	0xF4: 'ä',
	0xF5: 'ö',
	0xF6: 'ü',
}

func readGameString(data []byte) string {
	var sb strings.Builder
	for _, b := range data {
		if b == endOfString {
			break
		}
		if letter, ok := reverseCharmap[b]; ok {
			sb.WriteRune(letter)
		} else {
			sb.WriteByte(b)
		}
	}
	return sb.String()
}

func writeGameString(data []byte, s string, maxLength int) error {
	buffer := make([]byte, maxLength)
	pos := 0
	for _, letter := range s {
		if b, ok := charmap[letter]; ok {
			if pos >= maxLength {
				return fmt.Errorf("Cannot set game string to %s because the specified max length was only %d", s, maxLength)
			}
			buffer[pos] = b
			pos++
		} else {
			return fmt.Errorf("Cannot set game string to %s because the character '%c' is unsupported", s, letter)
		}
	}
	// Pad with null-terminating characters
	for pos < maxLength {
		buffer[pos] = endOfString
		pos++
	}
	copy(data, buffer)
	return nil
}
